--- Slide 1 ---
파이썬 편
자료구조와 함께 배우는 
알고리즘 입문

--- Slide 2 ---
정렬 알고리즘
06-1 정렬 알고리즘
06-2 버블 정렬
06-3 단순 선택 정렬
06-4 단순 삽입 정렬
06-5 셸 정렬
06
06-6 퀵 정렬
06-7 병합 정렬
06-8 힙 정렬
06-9 도수 정렬

--- Slide 3 ---
06-1 정렬 알고리즘
정렬이란?
정렬sorting
이름, 학번, 학점 등의 키key를 항목값의 대소 관계에 따라 데이터 집합을 일정한 순서로 바꾸어 늘어놓는 작업
오름차순ascending order
값이 작은 데이터를 앞쪽에 늘어놓는 것
내림차순descending order
값이 큰 데이터를 앞쪽에 늘어놓는 것
안정적인stable 정렬 알고리즘
값이 같은 원소의 순서가 정렬한 후에도 유지되는 것






내부 정렬internal sorting
정렬할 모든 데이터를 하나의 배열에 저장할 수 있는 경우 사용하는 알고리즘
외부 정렬external sorting
정렬할 데이터가 많아서 하나의 배열에서 저장할 수 없는 경우 사용하는 알고리즘

--- Slide 4 ---
06-2 버블 정렬
버블 정렬 알아보기 – (1)
버블 정렬bubble sort
이웃한 두 원소의 대소 관계를 비교하여 필요에 따라 교환을 반복하는 알고리즘
단순 교환 정렬이라고도 함
패스pass
비교 · 교환하는 과정
모든 정렬이 끝나려면 패스를 n – 1번 수행

--- Slide 5 ---
06-2 버블 정렬
버블 정렬 알아보기 – (2)
실습 6-1
버블 정렬 알고리즘
두 원소 a[j – 1]과 a[j]의 값을 비교하여 앞쪽 값이 뒷쪽 값보다 크면 교환





원소 비교 횟수


실제 원소를 교환하는 횟수는 배열의 원솟값에 영향을 받으므로 평균값은 절반인 n(n – 1) / 4번
(n - 1) + (n - 2) + … + 1 = n(n - 1) / 2

--- Slide 6 ---
06-2 버블 정렬
버블 정렬 알아보기 – (3)
실습 6-2
버블 정렬 과정을상세하게 출력하도록수정한 프로그램

비교하는 두 원소 사이에 교환할 경우 +,교환하지 않을 경우 – 출력

--- Slide 7 ---
06-2 버블 정렬
버블 정렬 알아보기 – (4)
실습 6-3
교환 횟수에 따라 중단 방식을 적용하여 개선한 프로그램

어떤 패스의 원소 교환 횟수가 0이면 모든 원소가 정렬을 완료한 경우이므로 그 이후의 패스는 불필요하다고 판단하여 정렬을 중단
이러한 중단 방식을 적용하면 정렬을 모두 마쳤거나 정렬이 거의 다 된 배열에서 비교 연산이 크게 줄어들어 실행 시간 단축 가능

실습 6-2와 비교 횟수 차이: 21번  18번

--- Slide 8 ---
06-2 버블 정렬
버블 정렬 알아보기 – (5)
실습 6-4
이미 정렬된 원소를 제외한 나머지만 비교 · 교환하도록 스캔 범위를 제한하는 방법으로 개선한 프로그램
버블 정렬의 첫 번째 패스
버블 정렬의 두 번째 패스

--- Slide 9 ---
06-2 버블 정렬
버블 정렬 알아보기 – (6)
실행 결과 비교하기
정렬

--- Slide 10 ---
06-2 버블 정렬
셰이커 정렬 알아보기 – (1)
버블 정렬 프로그램의 한계
정렬이 거의 완료된 아래 배열을 버블 정렬 프로그램으로 정렬하면?


가장 큰 원소인 9가 맨 앞에 있고, 한 패스에 하나씩 뒤로 이동하기 때문에 정렬 작업을 빠르게 마칠 수 없음

--- Slide 11 ---
06-2 버블 정렬
셰이커 정렬 알아보기 – (2)
셰이커 정렬shaker sort
홀수 패스에서는 가장 작은 원소를 맨 앞으로 이동시키고, 짝수 패스에서는 가장 큰 원소를 맨 뒤로 이동시켜 패스의 스캔 방향을 번갈아 바꾸는 방법으로 버블 정렬을 개선한 알고리즘
양방향 버블 정렬bidirectional bubble sort, 칵테일 정렬cocktail sort, 칵테일 셰이커 정렬cocktail shaker sort이라고 함

실습 6-5
실습 6-4의 버블 정렬을 셰이커 정렬로 개선하여 shaker_sort( ) 함수를 사용하는 프로그램
실습 6-4와 비교 횟수 차이: 21번  10번

--- Slide 12 ---
06-3 단순 선택 정렬
단순 선택 정렬 알아보기 – (1)
단순 선택 정렬straight selection sort
가장 작은 원소부터 선택해 알맞은 위치로 옮기는 작업을 반복하며 정렬하는 알고리즘
단순 선택 정렬에서 교환 과정



이 과정을 n – 1번 반복하면 정렬하지 않은 부분이 없어지면서 전체 정렬 완료

알고리즘의 개요
아직 정렬하지 않은 부분에서 값이 가장 작은 원소 a[min] 선택
a[min]과 아직 정렬하지 않은 부분에서 맨 앞에 있는 원소 교환

--- Slide 13 ---
06-3 단순 선택 정렬
단순 선택 정렬 알아보기 – (2)
실습 6-6
단순 선택 정렬 함수 selection_sort( )를 수행하는 프로그램

단순 선택 정렬 알고리즘의 원솟값을 비교하는 횟수(n2 - n) / 2번

서로 이웃하지 않는 떨어져 있는 원소를 교환하므로안정적이지 않은 정렬 알고리즘
원래 앞에 있던 3을 3L,뒤에 있던 3을 3R이라고 표기
결국 두 원소의 순서는정렬한 후 뒤바뀜

--- Slide 14 ---
06-4 단순 삽입 정렬
단순 삽입 정렬 알아보기 – (3)
단순 삽입 정렬straight insertion sort
주목한 원소보다 더 앞쪽에서 알맞은 위치로 삽입하며 정렬하는 알고리즘
단순 선택 정렬과 비슷해 보이지만 값이 가장 작은 원소를 선택하지 않는다는 점이 다름
단순 삽입 정렬의 삽입 과정



이 과정을 n – 1번 반복하면 정렬 완료

알고리즘의 개요
아직 정렬되지 않은 부분의 맨 앞 원소를 정렬된 부분의알맞은 위치에 삽입

--- Slide 15 ---
06-4 단순 삽입 정렬
단순 삽입 정렬 알아보기 – (4)
단순 삽입 정렬straight insertion sort
단순 삽입 정렬에서 원소 삽입









반복 제어 변수 j에 i를, tmp에 a[i]를 대입하고 종료 조건을 만족할 때까지 j를 1씩 감소시키면서 대입 작업 반복
종료 조건




스캔 작업 반복 조건
정렬된 배열의 왼쪽 끝에 도달한 경우
tmp보다 작거나 키값이 같은 원소 a[j– 1]을 발견할 경우
j가 0보다 큰 경우
a[j – 1]의 값이 tmp보다 큰 경우

--- Slide 16 ---
06-4 단순 삽입 정렬
단순 삽입 정렬 알아보기 – (5)
실습 6-7
단순 삽입 정렬을 수행하는 프로그램

이 알고리즘은 서로 떨어져 있는 원소를 교환하지 않으므로 안정적인 정렬 알고리즘
원소의 비교 횟수와 교환 횟수는 모두 n2 / 2번

단순 정렬 알고리즘의 시간 복잡도
단순 정렬(버블, 선택, 삽입) 알고리즘의 시간 복잡도는 모두 O(n2)으로 프로그램의 효율이 좋지 않음

--- Slide 17 ---
06-5 셸 정렬
단순 삽입 정렬의 문제
단순 삽입 정렬의 한계
여섯 번째 원소인 0을 삽입 정렬하려면 총 6번에걸쳐 원소를 이동(대입)해야 함

단순 삽입 정렬의 특징
장점: 이미 정렬을 마쳤거나 정렬이 거의 끝나가는 상태에서는 속도가 아주 빠름
단점: 삽입할 위치가 멀리 떨어져 있으면 이동 횟수가 많아짐

--- Slide 18 ---
06-5 셸 정렬
셸 정렬 알아보기 – (1)
셸 정렬shell sort
단순 삽입 정렬의 장점을 살리면서 단점을 보완
먼저 정렬할 배열의 원소를 그룹으로 나눠 각 그룹별로 정렬을 수행한 뒤 정렬된 그룹을 합치는 작업을 반복하여 원소의 이동 횟수를 줄이는 방법
시간 복잡도는 O(n1.25)로 단순 정렬의 시간 복잡도인 O(n2)보다 매우 빠르지만, 셸 정렬 알고리즘은 이웃하지 않고 떨어져 있는 원소를 서로 교환하므로 안정적인 정렬이 아님

셸 정렬 과정에서 수행하는 각각의 정렬을 h-정렬 이라고 함

4-정렬
서로 4칸 떨어진 원소를 정렬하는 방법

--- Slide 19 ---
06-5 셸 정렬
셸 정렬 알아보기 – (2)
셸 정렬shell sort
2-정렬
2칸 떨어진 원소를 모두 꺼내 두 그룹으로 나누고 정렬을 수행
마지막으로 배열 전체에 1-정렬 적용
셸 정렬의 전체 흐름

--- Slide 20 ---
06-5 셸 정렬
셸 정렬 알아보기 – (3)
실습 6-8
셸 정렬을 수행하는 프로그램

h의 초깃값은 n // 2
while 문을 반복할 때마다 다시 2로 나눈 값으로 업데이트
h의 변화
원소 수가 8이면 4 → 2 → 1
원소 수가 7이면 3 → 1

--- Slide 21 ---
06-5 셸 정렬
셸 정렬 알아보기 – (4)
h값의 선택
원소 수인 n이 8이라면 h값을 다음과 같이 변화시킴


h값은 n부터 감소하다가 마지막에는 1이 됨

배열 그룹을 나누는 과정
h = 4 → 2 → 1
를 학생 8명의 점수라고 가정
    처럼 학생 2명씩 4개 그룹으로 나누어 정렬
    처럼 학생 4명씩 2개 그룹으로 나누어 다시 정렬
    의 두 그룹을 합쳐서     가 되는 과정을 살펴보면,파란색 그룹과 검은색 그룹은 섞이지 않음
이렇게 두 그룹이 섞이지 않은 상태에서      로 합치면 다시 처음 단계인      와 같아짐
애써 그룹으로 나누어서 정렬했지만, 충분히 그 기능을 하지 못한다는 것을 보여줌

h값이 서로 배수가 되지 않아야 함


1부터 시작하여 3배한 값에 1을 더하는 수열 사용
a
b
c
b
c
c
a
h = … → 121 → 40 → 13 → 4 → 1

--- Slide 22 ---
06-5 셸 정렬
셸 정렬 알아보기 – (5)
실습 6-9
1부터 시작하여 3배한 값에 1을 더하는 수열을 사용하여 셸 정렬을 수행하는 프로그램

10~11행
h의 초깃값을 구함
1부터 시작해서 h * 3 + 1의 수열을 사용하는 작업을 반복하지만 n // 9를 넘지 않는 최댓값을 h에 대입
h의 초깃값이 지나치게 크면 효과가 없기 때문에 배열의 원소 수인 n을 9로 나누었을 대 그 몫을 넘지 않도록 정해야 함
13~21행
h값을 3으로 나누는 작업을 반복해서결국에 h값은 1이 됨

--- Slide 23 ---
06-6 퀵 정렬
퀵 정렬 알아보기
퀵 정렬quick sort
일반적으로 사용되는 아주 빠른 정렬 알고리즘
퀵 정렬의 예

배열을 두 그룹으로 나누기
배열을 두 그룹으로 나누는 순서


x: 피벗
pl: 왼쪽 끝 원소의 인덱스(왼쪽 커서)
pr: 오른쪽 끝 원소의 인덱스(오른쪽 커서)

피벗 이하인 원소를 배열 왼쪽으로, 피벗 이상인 원소를 배열 오른쪽으로 이동시키는 것이 목표





pl과 pr가 위치하는 원소 a[pl]과 a[pr]의 값을 교환
a[pl] >= x인 원소를 찾을 때까지 pl을 오른쪽 방향으로 스캔
a[pr] <= x인 원소를 찾을 때까지 pr를 왼쪽 방향으로 스캔

--- Slide 24 ---
06-6 퀵 정렬

배열을 두 그룹으로 나누기 – (1)
배열을 두 그룹으로 나누는 순서


pl과 pr가 서로 교차하면 그룹 나누는 과정 끝




그룹을 나누는 작업이 끝난 다음 pl > pr + 1일 때에 한해서 다음과 같은 그룹이 만들어짐
피벗 이하인 그룹: a[0], …, a[pl - 1]
피벗 이상인 그룹: a[pr + 1], …, a[n - 1]
피벗과 일치하는 그룹: a[pr + 1], …, a[pl - 1]
피벗과 일치하는 그룹이 생성된 예

--- Slide 25 ---
06-6 퀵 정렬
배열을 두 그룹으로 나누기 – (2)
실습 6-10: 배열을 두 그룹으로 나누는 프로그램 (배열 가운데에 있는 원소를 피벗으로 선택)

--- Slide 26 ---
06-6 퀵 정렬
퀵 정렬 만들기 – (1)
퀵 정렬 알고리즘
퀵 정렬의 배열 나누기
원소 수가 2개 이상인 그룹을 반복해서 나누기



퀵 정렬은 8퀸 문제와 같은 분할 정복 알고리즘이므로 재귀 호출을 사용하여 구현 가능

퀵 정렬은 서로 이웃하지 않는 원소를 교환하므로안정적이지 않은 알고리즘
pr가 a[0]보다 오른쪽에 위치하면(left < pr) 왼쪽 그룹 나누기
pl이 a[8]보다 왼쪽에 위치하면(pl < right) 오른쪽 그룹 나누기

--- Slide 27 ---
06-6 퀵 정렬
퀵 정렬 만들기 – (2)
실습 6-11
퀵 정렬을 수행하는 프로그램
qsort( ) 함수: 배열 a와 배열을 나누는 구간의 첫 번째 원소(left), 마지막 원소(right)의 인덱스를 전달받아 퀵 정렬을 수행

--- Slide 28 ---
06-6 퀵 정렬
비재귀적인 퀵 정렬 만들기 – (1)
실습 6-12
qsort( ) 함수를 비재귀적으로 구현하는 프로그램

데이터를 임시 저장하기 위해 스택 사용



스택의 크기는 right – left + 1이며 나누는 배열의 원소 수와 같음
range: 나눌 범위에서 맨 앞 원소의 인덱스와 맨 끝 원소의 인덱스를 조합한 튜플 스택

--- Slide 29 ---
06-6 퀵 정렬
비재귀적인 퀵 정렬 만들기 – (2)
실습 6-12
스택의 변화

--- Slide 30 ---
06-6 퀵 정렬
비재귀적인 퀵 정렬 만들기 – (3)
스택의 크기
퀵 정렬의 배열 나누기 예
피벗값은 2
배열을 스택에 푸시하는 순서를 정하는 규칙



일반적으로 원소 수가 적은 배열일수록 나누는 과정을 빠르게 마칠 수 있음
규칙 1과 같이 원소 수가 많은 그룹의 나누기를 나중에 하고, 원소 수가 적은 그룹의 나누기를 먼저 하면 스택에 동시에 쌓이는 데이터 개수는 적어짐
규칙 1, 2는 스택에 넣고 꺼내는 횟수(푸시, 팝)는 같지만, 동시에 쌓이는 데이터의 최대 개수는 다름

규칙 1에서 배열의 원소 수가 n이면, 스택에 쌓이는 데이터의 최대 개수는 log n보다 적음.
원소수 n이 100만 개라도 스택 최대 크기는 20이면 충분
규칙 1: 원소 수가 많은 쪽의 그룹을 먼저 푸시
규칙 2: 원소 수가 적은 쪽의 그룹을 먼저 푸시

--- Slide 31 ---
06-6 퀵 정렬
비재귀적인 퀵 정렬 만들기 – (4)
스택의 크기
규칙 1: 원소 수가 많은 그룹을 먼저 푸시
예) a[0]~a[1]의 왼쪽 그룹과 a[2]~a[7]의 오른쪽 그룹 중 원소 수가 많은 그룹(2,7)을 먼저 푸시
규칙 2: 원소 수가 적은 그룹을 먼저 푸시
예) a[0]~a[1]의 왼쪽 그룹과 a[2]~a[7]의 오른쪽 그룹 중 원소 수가 많은 그룹(0, 1)을 먼저 푸시

--- Slide 32 ---
06-6 퀵 정렬
피벗 선택하기
피벗 선택 방법
배열을 정렬한 뒤 가운데에 위치하는 값, 즉 전체에서 중앙값을 피벗으로 하는 것이 이상적!
하지만 정렬된 배열의 중앙값을 구하려면 그에 대한 처리가 필요하고, 많은 계산 시간이 걸림

피벗 선택 방법
방법 2: 피벗 선택과 분할 범위 축소











이 방법을 사용하면 나누는 그룹이 한쪽으로 치우치는 것을 방지하고, 스캔할 원소를 3개 줄일 수 있음
방법 1: 배열의 원소 수가 3 이상이면, 배열에서 임의의 원소 3개를 꺼내 중앙값인 원소를 피벗으로 선택
방법 2: 배열의 맨 앞, 가운데, 맨 끝 원소를 정렬한 뒤 가운데 원소와 맨 끝에서 두 번째 원소를 교환. 맨 끝에서 두 번째 원솟값 a[right – 1]이 피벗으로 선택되고, 그 동시에 나눌 대상을 a[left + 1] ~ a[right– 2]로 좁힘

--- Slide 33 ---
06-6 퀵 정렬
퀵 정렬의 시간 복잡도
퀵 정렬의 시간 복잡도
배열을 조금씩 나누어 보다 작은 문제를 푸는 과정을 반복하므로 시간 복잡도는 O(n log n)
정렬하는 배열의 초깃값이나 피벗을 선택하는 방법에 따라 실행 시간 복잡도가 증가하는 경우도 있음
예) 매번 1개의 원소와 나머지 원소로 나누어진다면 n번의 분할이 필요. 최악의 경우 시간 복잡도는 O(n2)
퀵 정렬은 원소 수가 적은 경우는 그다지 빠른 알고리즘이 아님
실습 6-13



chap06/quick_sort2.py 참조 (p.272)
원소 수가 9개 미만인 경우 단순 삽입 정렬로 전환
피벗 선택은 방법 2를 채택

--- Slide 34 ---
06-7 병합 정렬
정렬을 마친 배열의 병합
병합 정렬merge sort
배열을 앞부분과 뒷부분의 두 그룹으로 나누어 각각 정렬한 후 병합하는 작업을 반복하는 알고리즘

각 배열에서 주목하는 원소의 값을 비교하여 작은 쪽의 원소를 꺼내 새로운 배열에 저장
이 작업을 반복하며 정렬을 마친 배열을 만듦
실습 6-14
3개의 반복문을 늘어놓는 단순한 병합 알고리즘
시간 복잡도는 O(n)

chap06/merge.py 참조  (p. 277)

--- Slide 35 ---
06-7 병합 정렬
병합 정렬 만들기 – (1)
병합 정렬하는 방법





배열을 나누고
나눈 두 배열을 각각정렬한 뒤 병합하여배열 정렬을 완료
병합 정렬 알고리즘




배열 병합의 시간 복잡도는 O(n)
데이터 원소 수가 n일 때 병합 정렬의 단계는log n만큼 필요하므로 전체 시간 복잡도는 O(n log n)
병합 정렬 알고리즘은 서로 떨어져 있는 원소를 교환하는 것이 아니므로 안정적인 정렬 알고리즘
배열의 원소 수가 2개 이상인 경우
배열의 앞부분을 병합 정렬로 정렬
배열의 뒷부분을 병합 정렬로 정렬
배열의 앞부분과 뒷부분을 병합

--- Slide 36 ---
06-7 병합 정렬
병합 정렬 만들기 – (2)
실습 6-15
병합 정렬을 수행하는 프로그램
chap06/merge_sort.py 참조  (p.281)

정렬 수행 코드
_merge_sort( ) 함수: 재귀 호출을 통한 정렬 수행
병합 수행 코드 (다음 장에서 계속)

--- Slide 37 ---
06-7 병합 정렬
병합 정렬 만들기 – (3)
실습 6-15
병합 수행 코드
정렬을 마친 앞부분과 뒷부분을 작업용 배열 buff를 사용하여 병합


--- Slide 38 ---
06-8 힙 정렬
힙 정렬 알아보기
힙 정렬heap sort
힙의 특성을 이용하여 정렬하는 알고리즘
힙은 ‘부모의 값이 자식의 값보다 항상 크다’ 혹은 ‘부모의 값이 자식의 값보다 항상 작다’는 조건을 만족하는 완전 이진 트리 (두 값의 대소 관계가 일정)

완전 이진 트리를 힙으로 만들기

힙에서 부모와 자식 관계는 일정하지만, 형제 사이의 대소 관계는 일정하지 않음 부분 순서 트리partial ordered tree라고도 함

힙과 배열 원소의 대응
원소 a[i]에서
부모: a[(i - 1) // 2]
왼쪽 자식: a[i * 2 + 1]
오른쪽 자식: a[i * 2 + 2]

--- Slide 39 ---
06-8 힙 정렬
힙 정렬의 특징
힙 정렬의 특징
힙 정렬은 ‘힙에서 최댓값은 루트에 위치한다’는 특징을 이용하여 정렬하는 알고리즘

반복하는 작업



꺼낸 값을 나열하면 정렬이 끝난 배열이 완성됨(즉, 선택 정렬을 응용한 알고리즘)
힙 정렬에서 최댓값인 루트를 꺼낸 뒤 다시 남은 원소 중에서 최댓값을 구해야 함 남은 원소로 구성한 트리도 힙이 되도록 재구성 해야 함
힙에서 최댓값인 루트를 꺼낸다.
루트 이외의 부분을 힙으로 만든다.
힙 정렬의 시간 복잡도
힙 정렬의 시간 복잡도
힙 정렬은 선택 정렬을 응용한 알고리즘
단순 선택 정렬은 아직 정렬하지 않은 부분의 모든 원소 중에서 최댓값을 선택 최댓값인 원소를 선택하는 시간 복잡도는 O(n)
힙 정렬은 맨 앞 원소를 꺼내는 것만으로 최댓값을 구할 수 있지만 남은 원소를 힙으로 재구성해야 함 다시 힙으로 만드는 작업의 시간 복잡도는 O(log n)

원소의 개수만큼 반복했을 때, 단순 선택 정렬의 시간 복잡도는 O(n2), 힙 정렬의 시간 복잡도는 O(n log n)

--- Slide 40 ---
06-8 힙 정렬
루트를 삭제한 힙의 재구성

루트를 삭제하고 다시 힙으로 만들기 위해 원소를 알맞은 위치로 이동하는 순서
루트를 꺼낸다.
마지막 원소(가장 하단의 오른쪽에 위치한 원소)를 루트로 이동한다.
루트에서 시작하여 자신보다 값이 큰 자식과 자리를 바꾸고 아래쪽으로 내려가는 작업을 반복한다. 자식의 값이 작거나 리프의 위치에 도달하면 종료한다.

--- Slide 41 ---
06-8 힙 정렬
힙 정렬 알고리즘 알아보기

1. i값을 n - 1로 초기화 (n = 배열의 원소 수, i = 배열의 마지막 인덱스)
2. a[0]과 a[i]를 교환
3. a[0], a[1], …, a[i - 1]을 힙으로 만듦
4. i값을 1씩 감소시켜 0이 되면 종료하고, 그렇지 않으면 2로 돌아감

--- Slide 42 ---
06-8 힙 정렬
배열을 힙으로 만들기 – (1)
정렬되지 않은 서브 트리를 힙으로 만드는 과정


--- Slide 43 ---
06-8 힙 정렬
배열을 힙으로 만들기 – (2)
실습 6-16
힙 정렬 알고리즘을 구현한 프로그램
chap06/heap_sort.py 참조 (p. 294)

down_heap( )
배열 a에서 a[left] ~ a[right] 원소를 힙으로 만듦
a[left] 이외에는 모두 힙 상태라고 가정하고 a[left]를 아랫 부분의 알맞은 위치로 옮겨 힙 상태를 만듦
heap_sort( )
원소 수가 n인 배열 a를 힙 정렬하는 함수

1단계: down_heap( ) 함수를 호출하여 배열 a를 힙으로 만듦
2단계: 최댓값인 루트 a[0]을 꺼내 배열의 마지막 원소와 교환하고, 배열의 남은 부분을 다시 힙으로 만드는 과정을 반복하여 정렬을 수행

--- Slide 44 ---
06-9 도수 정렬
도수 정렬 알아보기 – (1)
도수 정렬counting sort
원소의 대소 관계를 판단하지 않고 빠르게 정렬하는 알고리즘
분포수 세기distribution counting 정렬이라고도 함

1단계: 도수 분포표 만들기
배열 a에 있는 학생들의 점수를 바탕으로 ‘각 점수에 해당하는 학생이 몇 명인가’를 나타내는 도수 분포표를 만들어야 함
도수 분포표를 저장하는 곳은 원소 수가 11개인 배열 f
배열 a의 점수를 바탕으로 배열 f의 값 증가

--- Slide 45 ---
06-9 도수 정렬
도수 정렬 알아보기 – (2)
도수 정렬counting sort
2단계: 누적 도수 분포표 만들기
0점부터 n점까지 학생이 몇 명 있는지를 누적된 값을 나타내는 누적 도수 분포표 만들기


--- Slide 46 ---
06-9 도수 정렬
도수 정렬 알아보기 – (3)
도수 정렬counting sort
3단계: 작업용 배열 만들기
배열 a의 원솟값과 누적 도수 분포표 f를 대조하여 정렬을 완료한 배열 만들기








배열 a의 맨 끝 원소인 a[8]은 3이고, 배열 f[3]의 값이 5이므로 0 ~ 3점 사이에 학생이 5명 있다는 의미
작업용 배열 b[4]에 3을 저장하고, f[3]의 값을 4로 감소


a[6]의 값도 3
a[8]을 작업용 배열 b에 저장하면서 f[3]의 값을 1 감소시켜 5에서 4로 만들었기 때문에, 여기서는 작업용 배열의 네 번째 원소인 b[3]에 3을 저장
값을 감소시켜서 중복 값을 배열 b에 저장할 수 있음

4단계: 배열 복사하기
배열 b의 모든 원소를 배열 a에 그대로 복사

--- Slide 47 ---
06-9 도수 정렬
도수 정렬 알아보기 – (4)
실습 6-17
도수 정렬을 수행하는 프로그램
chap06/counting_sort.py 참조 (p.301)


도수 정렬의 장∙단점 비교
장점: 데이터의 비교∙교환 작업이 필요 없어 매우 빠르다. for 문으로만 구현하고, 재귀 호출이나 이중 if 문이 없어 효율적이다.
단점: 도수 분포표가 필요하여 정렬 데이터의 최솟값과 최댓값을 아는 경우만 적용할 수 있다.

--- Slide 48 ---
마크 저커버그
Mark Zuckerberg, 페이스북 설립자
감사합니다

실패하더라도 무언가 배우는 것이
아무것도 시도하지 않는 것보다 낫다.
You are better off trying something and having it not work
and learning from that than not doing anything at all.

